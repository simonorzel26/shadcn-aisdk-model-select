{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "shadcn-aisdk-model-select",
  "type": "registry:component",
  "title": "Shadcn AI SDK Model Select",
  "description": "A comprehensive model select component that integrates with the Vercel AI SDK, providing model selection, settings, API key management, and context providers for building AI-powered applications.",
  "dependencies": [
    "lucide-react",
    "@simonorzel/ai-models",
    "clsx",
    "tailwind-merge",
    "cmdk",
    "@radix-ui/react-checkbox",
    "@radix-ui/react-dialog",
    "@radix-ui/react-label",
    "@radix-ui/react-select",
    "@radix-ui/react-slot",
    "@radix-ui/react-tabs"
  ],
  "registryDependencies": [
    "button",
    "input",
    "label",
    "select",
    "dialog",
    "tabs",
    "checkbox",
    "command",
    "tooltip",
    "card",
    "switch"
  ],
  "files": [
    {
      "path": "src/components/index.ts",
      "content": "export * from './ModelSettingsDialog';\nexport * from './ModelSelectDropdown';\nexport * from './ModelSelectionTab';\nexport * from './TinyModelSelector';\nexport { useApiKeys } from '@/hooks/useApiKeys';\nexport { ModelSelectionProvider, useModelSelection } from '@/contexts/ModelSelectionContext';",
      "type": "registry:component"
    },
    {
      "path": "src/components/ModelList.tsx",
      "content": "'use client';\n\nimport { useMemo } from 'react';\nimport { SelectItem } from '@/components/ui/select';\nimport { AiModel } from '@/types/model';\n\nexport function ModelList({ models }: { models: AiModel[] }) {\n  const groupedModels = useMemo(() => {\n    return models.reduce(\n      (acc, model) => {\n        if (!acc[model.provider]) {\n          acc[model.provider] = [];\n        }\n        acc[model.provider].push(model);\n        return acc;\n      },\n      {} as Record<string, AiModel[]>,\n    );\n  }, [models]);\n\n  if (Object.keys(groupedModels).length === 0) {\n    return (\n      <div className=\"px-2 py-4 text-center text-sm text-muted-foreground\">\n        No models available to display.\n      </div>\n    );\n  }\n\n  return (\n    <>\n      {Object.entries(groupedModels).map(([provider, providerModels]) => (\n        <div key={provider}>\n          <div className=\"px-2 py-1.5 text-sm font-semibold text-muted-foreground\">\n            {provider}\n          </div>\n          {providerModels.map((model, index) => (\n            <SelectItem\n              key={`${model.provider}-${model.model}-${index}`}\n              value={model.value}\n              className=\"pl-6\"\n            >\n              <span className=\"text-xs\">{model.model}</span>\n            </SelectItem>\n          ))}\n        </div>\n      ))}\n    </>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "src/components/ModelSelectDropdown.tsx",
      "content": "'use client';\n\nimport { useState, useMemo, useEffect } from 'react';\nimport {\n  Select,\n  SelectContent,\n  SelectTrigger,\n  SelectValue,\n} from '@/components/ui/select';\nimport { Button } from '@/components/ui/button';\nimport { Settings } from 'lucide-react';\nimport { ModelSettingsDialog } from './ModelSettingsDialog';\nimport { useModelSelection } from '@/contexts/ModelSelectionContext';\nimport { AiModel, ModelSelectDropdownSettings } from '@/types/model';\nimport { ModelList } from './ModelList';\n\nfunction ModelSelectWithSettings({\n  models,\n  placeholder,\n  settings,\n}: Omit<ModelSelectDropdownProps, 'onModelChange' | 'selectedModel'>) {\n  const [isSettingsOpen, setIsSettingsOpen] = useState(false);\n  const { state, selectedModels, selectedModel, setSelectedModel } = useModelSelection();\n\n  const allProviders = useMemo(() => {\n    return [...new Set(models.map(m => m.provider))];\n  }, [models]);\n\n  useEffect(() => {\n    if (state.isLoaded) {\n      const isSelectedModelInList = selectedModels.some(m => m.value === selectedModel);\n      if (!isSelectedModelInList && selectedModels.length > 0) {\n        setSelectedModel(selectedModels[0].value);\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedModels, state.isLoaded, selectedModel]);\n\n  const isLoading = !state.isLoaded;\n\n  const selectedModelLabel =\n    models.find(m => m.value === selectedModel)?.model || placeholder;\n\n  return (\n    <>\n      <Select onValueChange={setSelectedModel} value={selectedModel || ''} disabled={isLoading}>\n        <SelectTrigger className=\"flex-grow\">\n          <SelectValue asChild>\n            <span>{isLoading ? 'Loading...' : selectedModelLabel}</span>\n          </SelectValue>\n        </SelectTrigger>\n        <SelectContent className=\"max-h-96\">\n          {isLoading ? (\n            <div className=\"px-2 py-4 text-center text-sm text-muted-foreground\">\n              Loading...\n            </div>\n          ) : (\n            <ModelList models={selectedModels} />\n          )}\n        </SelectContent>\n      </Select>\n      <Button\n        variant=\"outline\"\n        size=\"icon\"\n        onClick={() => setIsSettingsOpen(true)}\n        className=\"h-10 w-10 shrink-0\"\n      >\n        <Settings className=\"h-4 w-4\" />\n        <span className=\"sr-only\">Model Settings</span>\n      </Button>\n      <ModelSettingsDialog\n        open={isSettingsOpen}\n        onOpenChange={setIsSettingsOpen}\n        providers={allProviders}\n        showApiKeys={typeof settings === 'object' ? settings.showApiKeys : true}\n      />\n    </>\n  );\n}\n\nexport interface ModelSelectDropdownProps {\n  models: AiModel[];\n  selectedModel?: string;\n  onModelChange?: (model: string) => void;\n  settings?: boolean | ModelSelectDropdownSettings;\n  placeholder?: string;\n  className?: string;\n}\n\nexport function ModelSelectDropdown({\n  models,\n  settings = false,\n  placeholder = 'Select a model...',\n  className,\n}: Omit<ModelSelectDropdownProps, 'onModelChange' | 'selectedModel'>) {\n  const hasSettings = settings !== false;\n  const { selectedModel, setSelectedModel, allModels } = useModelSelection();\n\n  if (!hasSettings) {\n    const selectedModelLabel =\n      allModels.find(m => m.value === selectedModel)?.model || placeholder;\n\n    return (\n      <div className={`flex items-center gap-4 ${className || ''}`}>\n        <Select onValueChange={setSelectedModel} value={selectedModel || ''}>\n          <SelectTrigger className=\"flex-grow\">\n            <SelectValue asChild>\n              <span>{selectedModelLabel}</span>\n            </SelectValue>\n          </SelectTrigger>\n          <SelectContent className=\"max-h-96\">\n            <ModelList models={models} />\n          </SelectContent>\n        </Select>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`flex items-center gap-4 ${className || ''}`}>\n      <ModelSelectWithSettings\n        models={models}\n        placeholder={placeholder}\n        className={className}\n        settings={settings}\n      />\n    </div>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "src/components/ModelSelectionTab.tsx",
      "content": "'use client';\n\nimport { useMemo, useState } from 'react';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Button } from '@/components/ui/button';\nimport { RotateCcw } from 'lucide-react';\nimport { AiModel } from '@/types/model';\nimport { useModelSelection } from '@/contexts/ModelSelectionContext';\nimport { Command, CommandInput } from '@/components/ui/command';\nimport { useModelSortAndFilter } from '@/hooks/useModelSortAndFilter';\nimport { useScrollToProvider } from '@/hooks/useScrollToProvider';\n\nconst useModelSelectionHandlers = (\n  configurableModels: AiModel[],\n  state: ReturnType<typeof useModelSelection>['state'],\n  setProviderToScrollTo: (provider: string | null) => void,\n) => {\n  const { toggleModel, toggleCategory, toggleProvider } = useModelSelection();\n\n  const handleToggleModel = (modelValue: string) => {\n    const model = configurableModels.find(m => m.value === modelValue);\n    if (!model) return;\n\n    const modelsInProvider = configurableModels.filter(m => m.provider === model.provider);\n    const hasSelectedModelsBefore = modelsInProvider.some(m => state.selectedModelIds.has(m.value));\n    const isTogglingOn = !state.selectedModelIds.has(modelValue);\n\n    if (isTogglingOn && !hasSelectedModelsBefore) {\n      setProviderToScrollTo(model.provider);\n    }\n    toggleModel(modelValue);\n  };\n\n  const handleToggleCategory = (provider: string, category: string, checked: boolean) => {\n    if (checked) {\n      const modelsInProvider = configurableModels.filter(m => m.provider === provider);\n      const hasSelectedModelsBefore = modelsInProvider.some(m => state.selectedModelIds.has(m.value));\n      if (!hasSelectedModelsBefore) {\n        setProviderToScrollTo(provider);\n      }\n    }\n    toggleCategory(provider, category, checked);\n  };\n\n  const handleToggleProvider = (provider: string, checked: boolean) => {\n    if (checked) {\n      const modelsInProvider = configurableModels.filter(m => m.provider === provider);\n      const hasSelectedModelsBefore = modelsInProvider.some(m => state.selectedModelIds.has(m.value));\n      if (!hasSelectedModelsBefore) {\n        setProviderToScrollTo(provider);\n      }\n    }\n    toggleProvider(provider, checked);\n  };\n\n  return { handleToggleModel, handleToggleCategory, handleToggleProvider };\n};\n\nexport function ModelSelectionTab() {\n  const [searchTerm, setSearchTerm] = useState('');\n  const { state, configurableModels, selectAll, deselectAll, resetToDefault } =\n    useModelSelection();\n\n  const { sortedProviderEntries, filteredAndGroupedModels } = useModelSortAndFilter(\n    configurableModels,\n    state.selectedModelIds,\n    searchTerm,\n  );\n\n  const { scrollContainerRef, setProviderToScrollTo, getProviderRef } = useScrollToProvider(\n    sortedProviderEntries,\n  );\n\n  const { handleToggleModel, handleToggleCategory, handleToggleProvider } =\n    useModelSelectionHandlers(configurableModels, state, setProviderToScrollTo);\n\n  const totalSelectedCount = state.selectedModelIds.size;\n  const filteredModelsInView = useMemo(() =>\n    Object.values(filteredAndGroupedModels).flatMap(cat => Object.values(cat).flat()),\n    [filteredAndGroupedModels]\n  );\n\n  const filteredSelectedCount = useMemo(() =>\n    filteredModelsInView.filter(m => state.selectedModelIds.has(m.value)).length,\n    [filteredModelsInView, state.selectedModelIds]\n  );\n\n  if (!state.isLoaded) {\n    return <div className=\"p-4 text-center text-sm text-muted-foreground\">Loading...</div>;\n  }\n\n  return (\n    <Command\n      className=\"space-y-3 bg-transparent\"\n      filter={(value, search) => {\n        if (value.includes(search)) return 1;\n        return 0;\n      }}\n    >\n      <div className=\"space-y-3\">\n        <CommandInput\n          placeholder=\"Search providers, models, or categories...\"\n          value={searchTerm}\n          onValueChange={setSearchTerm}\n          className=\"h-8 text-sm\"\n        />\n\n        <div className=\"flex items-center justify-between h-7\">\n          <div className=\"text-xs text-muted-foreground px-1\">\n            {searchTerm ? (\n              <>\n                {filteredSelectedCount} of {filteredModelsInView.length} matching models selected\n              </>\n            ) : (\n              `${totalSelectedCount} of ${configurableModels.length} models selected`\n            )}\n          </div>\n          <div className=\"flex items-center space-x-2\">\n            <Button variant=\"ghost\" size=\"sm\" onClick={selectAll} className=\"h-full px-2 text-xs\">\n              All\n            </Button>\n            <Button variant=\"ghost\" size=\"sm\" onClick={deselectAll} className=\"h-full px-2 text-xs\">\n              None\n            </Button>\n            <Button variant=\"ghost\" size=\"sm\" onClick={resetToDefault} className=\"h-full px-2 text-xs\">\n              <RotateCcw className=\"mr-1 h-3 w-3\" />\n              Reset\n            </Button>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"max-h-[350px] overflow-y-auto space-y-4 pr-1\" ref={scrollContainerRef}>\n        {sortedProviderEntries.length === 0 ? (\n          <div className=\"text-center py-8 text-sm text-muted-foreground\">\n            {searchTerm ? 'No models match your search.' : 'No models available.'}\n          </div>\n        ) : (\n          sortedProviderEntries.map(([provider, categories]) => {\n            const providerModels = Object.values(categories).flat();\n            const selectedProviderModels = providerModels.filter(m =>\n              state.selectedModelIds.has(m.value),\n            );\n            const isAllProviderSelected =\n              selectedProviderModels.length > 0 &&\n              selectedProviderModels.length === providerModels.length;\n            const isProviderIndeterminate =\n              selectedProviderModels.length > 0 && !isAllProviderSelected;\n\n            return (\n              <div\n                key={provider}\n                className=\"border rounded-md p-3 space-y-2\"\n                ref={getProviderRef(provider)}\n              >\n                <div className=\"flex items-center justify-between\">\n                  <label\n                    htmlFor={`provider-${provider}`}\n                    className=\"flex items-center space-x-2 cursor-pointer\"\n                  >\n                    <Checkbox\n                      id={`provider-${provider}`}\n                      checked={isAllProviderSelected}\n                      indeterminate={isProviderIndeterminate}\n                      onCheckedChange={checked => handleToggleProvider(provider, !!checked)}\n                      aria-label={`Select all ${provider} models`}\n                    />\n                    <span className=\"text-sm font-medium\">{provider}</span>\n                  </label>\n                </div>\n\n                <div className=\"space-y-3 pl-2\">\n                  {Object.entries(categories).map(([category, models]) => {\n                    const categoryModels = models;\n                    const selectedCategoryModels = categoryModels.filter(m =>\n                      state.selectedModelIds.has(m.value),\n                    );\n                    const isAllCategorySelected =\n                      selectedCategoryModels.length > 0 &&\n                      selectedCategoryModels.length === categoryModels.length;\n                    const isCategoryIndeterminate =\n                      selectedCategoryModels.length > 0 && !isAllCategorySelected;\n\n                    return (\n                      <div key={category} className=\"space-y-1\">\n                        <label\n                          htmlFor={`category-${provider}-${category}`}\n                          className=\"flex items-center space-x-2 cursor-pointer\"\n                        >\n                          <Checkbox\n                            id={`category-${provider}-${category}`}\n                            checked={isAllCategorySelected}\n                            indeterminate={isCategoryIndeterminate}\n                            onCheckedChange={checked =>\n                              handleToggleCategory(provider, category, !!checked)\n                            }\n                            aria-label={`Select all ${category} models from ${provider}`}\n                          />\n                          <div className=\"text-xs font-medium text-muted-foreground capitalize\">\n                            {category} ({models.length})\n                          </div>\n                        </label>\n                        <div className=\"space-y-1 pl-6\">\n                          {models.map((model, index) => (\n                            <label\n                              key={`${model.provider}-${model.model}-${index}`}\n                              htmlFor={`model-${model.value}`}\n                              className=\"flex items-center space-x-2 cursor-pointer\"\n                            >\n                              <Checkbox\n                                id={`model-${model.value}`}\n                                checked={state.selectedModelIds.has(model.value)}\n                                onCheckedChange={() => handleToggleModel(model.value)}\n                              />\n                              <span className=\"text-xs text-muted-foreground truncate flex-1\">\n                                {model.model}\n                              </span>\n                            </label>\n                          ))}\n                        </div>\n                      </div>\n                    );\n                  })}\n                </div>\n              </div>\n            );\n          })\n        )}\n      </div>\n    </Command>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "src/components/ModelSettingsDialog.tsx",
      "content": "'use client';\n\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogDescription,\n} from '@/components/ui/dialog';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { useApiKeys } from '@/hooks/useApiKeys';\nimport { ModelSelectionTab } from './ModelSelectionTab';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\n\nexport interface ModelSettingsDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  providers: string[];\n  showApiKeys?: boolean;\n}\n\nexport function ModelSettingsDialog({\n  open,\n  onOpenChange,\n  providers,\n  showApiKeys = true,\n}: ModelSettingsDialogProps) {\n  const { apiKeys, setApiKey } = useApiKeys(providers);\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-3xl max-h-[80vh] flex flex-col\">\n        <DialogHeader>\n          <DialogTitle>Model Settings</DialogTitle>\n          <DialogDescription>\n            {showApiKeys\n              ? 'Manage your API keys and select the models you want to use.'\n              : 'Select the models you want to display in the dropdown.'}\n          </DialogDescription>\n        </DialogHeader>\n        <div className=\"flex-grow overflow-y-auto pt-4\">\n          {showApiKeys ? (\n            <Tabs defaultValue=\"modelSelection\">\n              <TabsList className=\"grid w-full grid-cols-2\">\n                <TabsTrigger value=\"modelSelection\">Model Selection</TabsTrigger>\n                <TabsTrigger value=\"apiKeys\">API Keys</TabsTrigger>\n              </TabsList>\n              <TabsContent value=\"modelSelection\">\n                <ModelSelectionTab />\n              </TabsContent>\n              <TabsContent value=\"apiKeys\">\n                <div className=\"p-4 space-y-4\">\n                  {providers.map(provider => (\n                    <div key={provider} className=\"space-y-2\">\n                      <Label htmlFor={`${provider}-key`}>{provider}</Label>\n                      <Input\n                        id={`${provider}-key`}\n                        type=\"password\"\n                        placeholder={`Enter ${provider} API Key`}\n                        value={apiKeys[provider] || ''}\n                        onChange={e => setApiKey(provider, e.target.value)}\n                      />\n                    </div>\n                  ))}\n                </div>\n              </TabsContent>\n            </Tabs>\n          ) : (\n            <ModelSelectionTab />\n          )}\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "src/components/TinyModelSelector.tsx",
      "content": "'use client';\n\nimport {\n  Select,\n  SelectContent,\n  SelectTrigger,\n} from '@/components/ui/select';\nimport { Brain } from 'lucide-react';\nimport { ModelList } from './ModelList';\nimport { useModelSelection } from '@/contexts/ModelSelectionContext';\n\nexport interface TinyModelSelectorProps {\n  placeholder?: string;\n  className?: string;\n}\n\nexport function TinyModelSelector({\n  placeholder = 'Select Model',\n  className,\n}: TinyModelSelectorProps) {\n  const { selectedModel, setSelectedModel, selectedModels, allModels, state } =\n    useModelSelection();\n\n  const isLoading = !state.isLoaded;\n\n  const selectedModelLabel =\n    allModels.find(m => m.value === selectedModel)?.model || placeholder;\n\n  return (\n    <div className={`flex items-center ${className || ''}`}>\n      <Select\n        onValueChange={setSelectedModel}\n        value={selectedModel || ''}\n        disabled={isLoading}\n      >\n        <SelectTrigger\n          size=\"sm\"\n          className=\"gap-0 m-0 px-2 py-0 text-[10px] border rounded-md bg-background hover:bg-muted/80 focus:ring-0 focus:ring-none focus:ring-offset-0 border-none focus:border-none active:border-none focus:outline-none focus-visible:ring-0 focus-visible:ring-offset-0\"\n        >\n          <div className=\"flex items-end\">\n            <Brain className=\"h-0.5 w-0.5 mr-1 p-0.5 text-muted-foreground\" />\n            <span className=\"truncate\">\n              {isLoading ? '...' : selectedModelLabel}\n            </span>\n          </div>\n        </SelectTrigger>\n        <SelectContent className=\"max-h-96\">\n          {!isLoading && <ModelList models={selectedModels} />}\n        </SelectContent>\n      </Select>\n    </div>\n  );\n}",
      "type": "registry:component"
    },
    {
      "path": "src/contexts/ModelSelectionContext.tsx",
      "content": "'use client';\n\nimport React, {\n  createContext,\n  useContext,\n  useReducer,\n  useEffect,\n  ReactNode,\n  useMemo,\n  useState,\n} from 'react';\nimport { AiModel } from '@/types/model';\n\ninterface ModelSelectionState {\n  selectedModelIds: Set<string>;\n  isLoaded: boolean;\n}\n\ntype ModelSelectionAction =\n  | { type: 'INITIALIZE'; selectedIds: string[] }\n  | { type: 'TOGGLE_MODEL'; modelId: string }\n  | { type: 'SELECT_ALL_MODELS' }\n  | { type: 'DESELECT_ALL_MODELS' }\n  | { type: 'RESET_TO_DEFAULT' }\n  | { type: 'TOGGLE_PROVIDER'; provider: string; shouldSelect: boolean }\n  | { type: 'TOGGLE_CATEGORY'; provider: string; category: string; shouldSelect: boolean };\n\ninterface ModelSelectionContextType {\n  state: ModelSelectionState;\n  selectedModels: AiModel[];\n  configurableModels: AiModel[];\n  allModels: AiModel[];\n  toggleModel: (modelId: string) => void;\n  selectAll: () => void;\n  deselectAll: () => void;\n  resetToDefault: () => void;\n  toggleProvider: (provider: string, shouldSelect: boolean) => void;\n  toggleCategory: (provider: string, category: string, shouldSelect: boolean) => void;\n  selectedModel: string;\n  setSelectedModel: (modelId: string) => void;\n}\n\nconst ModelSelectionContext = createContext<ModelSelectionContextType | null>(null);\n\nconst SELECTED_MODELS_STORAGE_KEY_PREFIX = 'ai-model-selector-selected-models';\nconst SELECTED_MODEL_STORAGE_KEY = 'ai-model-selector:selectedModel';\n\nfunction modelSelectionReducer(\n  state: ModelSelectionState,\n  action: ModelSelectionAction,\n  configurableModels: AiModel[]\n): ModelSelectionState {\n  switch (action.type) {\n    case 'INITIALIZE':\n      return {\n        selectedModelIds: new Set(action.selectedIds),\n        isLoaded: true,\n      };\n\n    case 'TOGGLE_MODEL': {\n      const newSet = new Set(state.selectedModelIds);\n      if (newSet.has(action.modelId)) {\n        newSet.delete(action.modelId);\n      } else {\n        newSet.add(action.modelId);\n      }\n      return {\n        ...state,\n        selectedModelIds: newSet,\n      };\n    }\n\n    case 'SELECT_ALL_MODELS':\n      return {\n        ...state,\n        selectedModelIds: new Set(configurableModels.map(m => m.value)),\n      };\n\n    case 'DESELECT_ALL_MODELS':\n      return {\n        ...state,\n        selectedModelIds: new Set(),\n      };\n\n    case 'RESET_TO_DEFAULT':\n      return {\n        ...state,\n        selectedModelIds: new Set(configurableModels.map(m => m.value)),\n      };\n\n    case 'TOGGLE_PROVIDER': {\n      const providerModelIds = configurableModels\n        .filter(m => m.provider === action.provider)\n        .map(m => m.value);\n      const newSet = new Set(state.selectedModelIds);\n      if (action.shouldSelect) {\n        providerModelIds.forEach(id => newSet.add(id));\n      } else {\n        providerModelIds.forEach(id => newSet.delete(id));\n      }\n      return { ...state, selectedModelIds: newSet };\n    }\n\n    case 'TOGGLE_CATEGORY': {\n      const categoryModelIds = configurableModels\n        .filter(m => m.provider === action.provider && m.category === action.category)\n        .map(m => m.value);\n      const newSet = new Set(state.selectedModelIds);\n      if (action.shouldSelect) {\n        categoryModelIds.forEach(id => newSet.add(id));\n      } else {\n        categoryModelIds.forEach(id => newSet.delete(id));\n      }\n      return { ...state, selectedModelIds: newSet };\n    }\n\n    default:\n      return state;\n  }\n}\n\ninterface ModelSelectionProviderProps {\n  children: ReactNode;\n  configurableModels: AiModel[];\n  initialModel?: string;\n}\n\nexport function ModelSelectionProvider({\n  children,\n  configurableModels,\n  initialModel = '',\n}: ModelSelectionProviderProps) {\n  const [selectedModel, setSelectedModel] = useState<string>(initialModel);\n\n  const storageKey = useMemo(() => {\n    const modelHash = configurableModels.map(m => m.value).sort().join(',');\n    return `${SELECTED_MODELS_STORAGE_KEY_PREFIX}-${modelHash}`;\n  }, [configurableModels]);\n\n  const reducerWithConfig = (state: ModelSelectionState, action: ModelSelectionAction) =>\n    modelSelectionReducer(state, action, configurableModels);\n\n  const [state, dispatch] = useReducer(reducerWithConfig, {\n    selectedModelIds: new Set<string>(),\n    isLoaded: false,\n  });\n\n  useEffect(() => {\n    try {\n      // Load which models are selected for the dropdown\n      const stored = localStorage.getItem(storageKey);\n      const configurableModelIds = new Set(configurableModels.map(m => m.value));\n\n      if (stored) {\n        const parsedIds = JSON.parse(stored) as string[];\n        const validIds = parsedIds.filter(id => configurableModelIds.has(id));\n        dispatch({ type: 'INITIALIZE', selectedIds: validIds });\n      } else {\n        const defaultIds = Array.from(configurableModelIds);\n        dispatch({ type: 'INITIALIZE', selectedIds: defaultIds });\n      }\n\n      // Load the currently selected model\n      const storedModel = localStorage.getItem(SELECTED_MODEL_STORAGE_KEY);\n      if (storedModel) {\n        setSelectedModel(JSON.parse(storedModel));\n      } else if (initialModel) {\n        setSelectedModel(initialModel);\n      }\n    } catch (error) {\n      console.error('Failed to load state from localStorage:', error);\n      const defaultIds = configurableModels.map(model => model.value);\n      dispatch({ type: 'INITIALIZE', selectedIds: defaultIds });\n      if (initialModel) setSelectedModel(initialModel);\n    }\n  }, [configurableModels, storageKey, initialModel]);\n\n  useEffect(() => {\n    if (state.isLoaded) {\n      try {\n        // Save which models are selected for the dropdown\n        const ids = Array.from(state.selectedModelIds);\n        localStorage.setItem(storageKey, JSON.stringify(ids));\n\n        // Save the currently selected model\n        localStorage.setItem(SELECTED_MODEL_STORAGE_KEY, JSON.stringify(selectedModel));\n      } catch (error) {\n        console.error('Failed to save state to localStorage:', error);\n      }\n    }\n  }, [state.selectedModelIds, selectedModel, state.isLoaded, storageKey]);\n\n  const selectedModels = useMemo(() =>\n    configurableModels.filter(model => state.selectedModelIds.has(model.value)),\n    [configurableModels, state.selectedModelIds]\n  );\n\n  const toggleModel = (modelId: string) => dispatch({ type: 'TOGGLE_MODEL', modelId });\n  const selectAll = () => dispatch({ type: 'SELECT_ALL_MODELS' });\n  const deselectAll = () => dispatch({ type: 'DESELECT_ALL_MODELS' });\n  const resetToDefault = () => dispatch({ type: 'RESET_TO_DEFAULT' });\n  const toggleProvider = (provider: string, shouldSelect: boolean) =>\n    dispatch({ type: 'TOGGLE_PROVIDER', provider, shouldSelect });\n  const toggleCategory = (provider: string, category: string, shouldSelect: boolean) =>\n    dispatch({ type: 'TOGGLE_CATEGORY', provider, category, shouldSelect });\n\n  const contextValue: ModelSelectionContextType = {\n    state,\n    selectedModels,\n    configurableModels,\n    allModels: configurableModels,\n    toggleModel,\n    selectAll,\n    deselectAll,\n    resetToDefault,\n    toggleProvider,\n    toggleCategory,\n    selectedModel,\n    setSelectedModel,\n  };\n\n  return (\n    <ModelSelectionContext.Provider value={contextValue}>\n      {children}\n    </ModelSelectionContext.Provider>\n  );\n}\n\nexport function useModelSelection(): ModelSelectionContextType {\n  const context = useContext(ModelSelectionContext);\n  if (!context) {\n    throw new Error('useModelSelection must be used within a ModelSelectionProvider');\n  }\n  return context;\n}",
      "type": "registry:component"
    },
    {
      "path": "src/hooks/useApiKeys.ts",
      "content": "import { useState, useEffect, useCallback } from 'react';\nimport { ProviderApiKeys } from '@/types/model';\n\nconst API_KEYS_STORAGE_KEY = 'llm-model-selector-api-keys';\n\nexport function useApiKeys(providers: string[]) {\n  const [apiKeys, setApiKeys] = useState<ProviderApiKeys>({});\n  const [isLoaded, setIsLoaded] = useState(false);\n\n  useEffect(() => {\n    const storedKeys = localStorage.getItem(API_KEYS_STORAGE_KEY);\n    if (storedKeys) {\n      try {\n        setApiKeys(JSON.parse(storedKeys));\n      } catch (error) {\n        console.error('Failed to parse stored API keys:', error);\n      }\n    }\n    setIsLoaded(true);\n  }, []);\n\n  const setApiKey = useCallback((provider: string, key: string) => {\n    setApiKeys(prevKeys => {\n      const newKeys = { ...prevKeys, [provider]: key };\n      try {\n    localStorage.setItem(API_KEYS_STORAGE_KEY, JSON.stringify(newKeys));\n      } catch (error) {\n        console.error('Failed to save API key to localStorage', error);\n      }\n      return newKeys;\n    });\n  }, []);\n\n  const getAvailableProviders = () => {\n    return Object.entries(apiKeys)\n      .filter(([, value]) => value && value.trim() !== '')\n      .map(([key]) => key);\n  };\n\n  return {\n    apiKeys,\n    setApiKey,\n    getAvailableProviders,\n    isLoaded\n  };\n}",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/useModelSortAndFilter.ts",
      "content": "'use client';\n\nimport { useMemo } from 'react';\nimport { AiModel } from '@/types/model';\n\nexport function useModelSortAndFilter(\n  models: AiModel[],\n  selectedModelIds: Set<string>,\n  searchTerm: string,\n) {\n  const filteredAndGroupedModels = useMemo(() => {\n    const groups: Record<string, Record<string, AiModel[]>> = {};\n    const searchLower = searchTerm.toLowerCase().trim();\n\n    models.forEach(model => {\n      if (searchLower) {\n        const providerMatch = model.provider.toLowerCase().includes(searchLower);\n        const modelMatch = model.model.toLowerCase().includes(searchLower);\n        const categoryMatch = model.category.toLowerCase().includes(searchLower);\n\n        if (!providerMatch && !modelMatch && !categoryMatch) {\n          return;\n        }\n      }\n\n      if (!groups[model.provider]) {\n        groups[model.provider] = {};\n      }\n      if (!groups[model.provider][model.category]) {\n        groups[model.provider][model.category] = [];\n      }\n      groups[model.provider][model.category].push(model);\n    });\n\n    for (const provider in groups) {\n      for (const category in groups[provider]) {\n        groups[provider][category].sort((a, b) => {\n          return a.model.localeCompare(b.model);\n        });\n      }\n    }\n\n    return groups;\n  }, [models, searchTerm]);\n\n  const sortedProviderEntries = useMemo(() => {\n    const providers = Object.entries(filteredAndGroupedModels);\n\n    providers.sort(([providerA, categoriesA], [providerB, categoriesB]) => {\n      const modelsA = Object.values(categoriesA).flat();\n      const modelsB = Object.values(categoriesB).flat();\n\n      const hasSelectedA = modelsA.some(m => selectedModelIds.has(m.value));\n      const hasSelectedB = modelsB.some(m => selectedModelIds.has(m.value));\n\n      if (hasSelectedA !== hasSelectedB) {\n        return hasSelectedA ? -1 : 1;\n      }\n\n      return providerA.localeCompare(providerB);\n    });\n\n    return providers;\n  }, [filteredAndGroupedModels, selectedModelIds]);\n\n  return { sortedProviderEntries, filteredAndGroupedModels };\n}",
      "type": "registry:hook"
    },
    {
      "path": "src/hooks/useScrollToProvider.ts",
      "content": "'use client';\n\nimport { useState, useRef, useEffect } from 'react';\n\nexport function useScrollToProvider(sortedProviderEntries: [string, any][]) {\n  const scrollContainerRef = useRef<HTMLDivElement>(null);\n  const providerRefs = useRef<Map<string, HTMLDivElement | null>>(new Map());\n  const [providerToScrollTo, setProviderToScrollTo] = useState<string | null>(null);\n\n  useEffect(() => {\n    if (providerToScrollTo) {\n      const node = providerRefs.current.get(providerToScrollTo);\n      if (node) {\n        node.scrollIntoView({\n          behavior: 'smooth',\n          block: 'start',\n        });\n      }\n      setProviderToScrollTo(null);\n    }\n  }, [providerToScrollTo, sortedProviderEntries]);\n\n  const getProviderRef = (provider: string) => (node: HTMLDivElement | null) => {\n    if (node) {\n      providerRefs.current.set(provider, node);\n    } else {\n      providerRefs.current.delete(provider);\n    }\n  };\n\n  return {\n    scrollContainerRef,\n    setProviderToScrollTo,\n    getProviderRef,\n  };\n}",
      "type": "registry:hook"
    },
    {
      "path": "src/lib/config.ts",
      "content": "import { ModelSelectorConfig } from '@/types/model';\n\nexport const defaultModelSelectorConfig: ModelSelectorConfig = {\n  enabledCategories: ['chat'],\n  enabledProviders: [\n    '@langdb/vercel-provider',\n    'sarvam-ai-provider',\n  ],\n};\n\nexport function createModelSelectorConfig(\n  config?: Partial<ModelSelectorConfig>\n): ModelSelectorConfig {\n  return {\n    ...defaultModelSelectorConfig,\n    ...config,\n  };\n}\n\nexport const popularProviders = [\n  '@langdb/vercel-provider',\n  'sarvam-ai-provider',\n];\n\nexport const allCategories = ['chat', 'image', 'embedding', 'transcription'] as const;\n\nexport function getProviderDisplayName(provider: string): string {\n  switch (provider) {\n    case '@langdb/vercel-provider':\n      return 'Vercel AI';\n    case 'sarvam-ai-provider':\n      return 'Sarvam AI';\n    default:\n      return provider\n        .replace(/-provider$/, '')\n        .replace(/@langdb\\//, '')\n        .replace(/[-_]/g, ' ')\n        .replace(/\\b\\w/g, (l) => l.toUpperCase());\n  }\n}\n\nexport function getModelDisplayName(model: string): string {\n  return model\n    .replace(/^(openrouter|togetherai)\\//, '')\n    .replace(/[-_]/g, ' ')\n    .replace(/\\b\\w/g, (l) => l.toUpperCase());\n}",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/models.ts",
      "content": "import { AiModel } from '@/types/model';\nimport { AI_SDK_MODELS } from '@simonorzel26/ai-models';\n\ntype ModelGroup = { [key: string]: readonly string[] };\ntype Categories = { [key: string]: ModelGroup };\n\nconst allModels: AiModel[] = Object.entries(AI_SDK_MODELS).flatMap(\n  ([provider, categories]: [string, Categories]) =>\n    Object.entries(categories).flatMap(\n      ([category, modelsGroup]: [string, ModelGroup]) =>\n        Object.values(modelsGroup).flatMap((modelIds: readonly string[]) =>\n          modelIds.map(\n            (modelId): AiModel => ({\n              value: `${provider}:${modelId}`,\n              provider,\n              model: modelId,\n              label: modelId,\n              category: category as AiModel['category'],\n            }),\n          ),\n        ),\n    ),\n);\n\nexport const aiModels: AiModel[] = allModels;\n\nexport function getFilteredModels({\n  providers,\n  categories,\n}: {\n  providers?: string[];\n  categories?: AiModel['category'][];\n}): AiModel[] {\n  let models: AiModel[] = allModels;\n\n  if (providers && providers.length > 0) {\n    models = models.filter(model => providers.includes(model.provider));\n  }\n\n  if (categories && categories.length > 0) {\n    models = models.filter(model => categories.includes(model.category));\n  }\n\n  return models;\n}\n\nexport const availableProviders = [...new Set(aiModels.map(model => model.provider))];",
      "type": "registry:lib"
    },
    {
      "path": "src/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/types/model.ts",
      "content": "export type AiModel = {\n  value: string;\n  provider: string;\n  model: string;\n  label: string;\n  category: 'chat' | 'text' | 'embedding' | 'image' | 'moderation' | 'rerank' | 'transcription';\n  context_window?: number;\n};\n\nexport interface ModelGroup {\n  provider: string;\n  models: AiModel[];\n}\n\nexport interface ModelSelectDropdownSettings {\n  enabledProviders?: string[];\n  enabledCategories?: ('chat' | 'image' | 'embedding' | 'transcription' | 'speech' | 'completion' | 'responses')[];\n  showApiKeys?: boolean;\n}\n\nexport interface ModelSelectorConfig {\n  enabledProviders?: string[];\n  enabledCategories?: AiModel['category'][];\n}\n\nexport interface ProviderApiKeys {\n  [provider: string]: string;\n}\n\nexport interface ProviderVisibilitySettings {\n  [provider: string]: boolean;\n}",
      "type": "registry:lib"
    }
  ]
}